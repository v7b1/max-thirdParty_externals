#include "ext.h"#include "ext_obex.h"#include "z_dsp.h"// author: David Zicarelli (?)/*    reviving the good old 'rufus~' object...    vb, Oct.2021 */typedef struct _rufus{	t_pxobject x_obj;    long x_setcount;    long x_actcount;    long x_powerlock;    long x_waiting;    double x_prev;    double x_outcount;} t_rufus;static t_class *rufus_class;t_int *rufus_perform(t_int *w);void rufus_dsp(t_rufus *x, t_signal **sp);void rufus_dsp64(t_rufus *x, t_object *dsp64, short *count, double samplerate,                 long maxvectorsize, long flags);void rufus_perform64(t_rufus *x, t_object *dsp64, double **ins, long numins,                     double **outs, long numouts, long sampleframes, long flags, void *userparam);void *rufus_new(long setcount);void rufus_assist(t_rufus *x, void *b, long m, long a, char *s);void rufus_bang(t_rufus *x);void rufus_stop(t_rufus *x);void rufus_int(t_rufus *x, long n);void rufus_in1(t_rufus *x, long n);void rufus_list(t_rufus *x, t_symbol *s, short argc, t_atom *argv);void rufus_float(t_rufus *x, double f);void rufus_powerlock(t_rufus *x);void ext_main(void* r){    t_class *c;    c = class_new("rufus~", (method)rufus_new, (method)dsp_free, (short)sizeof(t_rufus),    	0L, A_DEFLONG, 0);    class_addmethod(c, (method)rufus_dsp, "dsp", A_CANT, 0);    class_addmethod(c, (method)rufus_dsp64, "dsp64", A_CANT, 0);    class_addmethod(c, (method)rufus_assist, "assist", A_CANT, 0);    class_addmethod(c, (method)rufus_bang, "bang", 0);    class_addmethod(c, (method)rufus_powerlock, "powerlock", 0);    class_addmethod(c, (method)rufus_stop, "stop", 0);    class_addmethod(c, (method)rufus_int, "int", A_LONG, 0);    class_addmethod(c, (method)rufus_float, "float", A_FLOAT, 0);        class_dspinit(c);    class_register(CLASS_BOX, c);    rufus_class = c;        object_post(NULL, "rufus~ oct. 2021");}t_int *rufus_perform(t_int *w){	t_rufus *x = (t_rufus *)(w[1]);	t_float *in = (t_float *)(w[2]);	t_float *out = (t_float *)(w[3]);    int n = (int)(w[4]);	float prev,val;	double outcount;	Boolean starting = false;		if (x->x_obj.z_disabled)		goto out;	prev = x->x_prev;	outcount = x->x_outcount;	if (x->x_powerlock) {		while (n--)			*out++ = *in++;		goto out;	} else if (x->x_waiting) {		while (n--) {			val = *in++;			if (prev > val) {				starting = true;				x->x_waiting = false;				prev = val;				outcount = 0.;				n++;				break;			}			prev = val;			*out++ = -1.;		}	} else if (x->x_actcount > 0)		starting = true;		if (starting && n > 0) {		while (n--) {			val = *in++;			if (prev > val)	{ // a sawtooth reset				if (!--x->x_actcount) {					prev = val;					*out++ = -.1;					break;				}			}			*out++ = outcount++;			prev = val;		}	}		// anything else is over		if (n > 0) {		while (n--) {			*out++ = -1.;		}	}	x->x_prev = prev;	x->x_outcount = outcount;out:    return (w+5);}void rufus_dsp(t_rufus *x, t_signal **sp){	x->x_prev = 0.;	x->x_outcount = 0.;	dsp_add(rufus_perform, 4, x, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);}void rufus_perform64(t_rufus *x, t_object *dsp64, double **ins, long numins,                       double **outs, long numouts, long sampleframes, long flags, void *userparam){    t_double *in = ins[0];    t_double *out = outs[0];    long n = sampleframes;    double prev, val;    double outcount;    Boolean starting = false;        if (x->x_obj.z_disabled)        return;        prev = x->x_prev;    outcount = x->x_outcount;    if (x->x_powerlock) {        while (n--)            *out++ = *in++;        return;    } else if (x->x_waiting) {        while (n--) {            val = *in++;            if (prev > val) {                starting = true;                x->x_waiting = false;                prev = val;                outcount = 0.;                n++;                break;            }            prev = val;            *out++ = -1.;        }    } else if (x->x_actcount > 0)        starting = true;        if (starting && n > 0) {        while (n--) {            val = *in++;            if (prev > val)    { // a sawtooth reset                if (!--x->x_actcount) {                    prev = val;                    *out++ = -.1;                    break;                }            }            *out++ = outcount++;            prev = val;        }    }        // anything else is over        if (n > 0) {        while (n--) {            *out++ = -1.;        }    }    x->x_prev = prev;    x->x_outcount = outcount;}void rufus_dsp64(t_rufus *x, t_object *dsp64, short *count, double samplerate,                   long maxvectorsize, long flags){//        object_method(dsp64, gensym("dsp_add64"), x, sigmund_perform64, 0, NULL);        object_method_direct(void, (t_object*, t_object*, t_perfroutine64, long, void*),                             dsp64, gensym("dsp_add64"), (t_object*)x, (t_perfroutine64)rufus_perform64, 0, NULL);}void rufus_assist(t_rufus *x, void *b, long m, long a, char *s){	if (m==1) {		switch (a) {			case 0: sprintf(s,"(signal) Input from fft~, int Starts Repeating"); break;		}	} 	else if (m==2) {		switch (a) {			case 0: sprintf(s,"(signal) Repeated Input or -1"); break;		}	}}void rufus_bang(t_rufus *x){	x->x_actcount = x->x_setcount;	x->x_waiting = true;	x->x_powerlock = false;}void rufus_stop(t_rufus *x){	x->x_actcount = 0;	x->x_waiting = false;	x->x_powerlock = false;}void rufus_int(t_rufus *x, long n){	if (n > 0) {		x->x_actcount = x->x_setcount = n;		x->x_waiting = true;		x->x_powerlock = false;	} else		rufus_stop(x);}void rufus_float(t_rufus *x, double f){	rufus_int(x,(long)f);}void rufus_powerlock(t_rufus *x){	x->x_powerlock = true;}void *rufus_new(long setcount){    t_rufus *x;    if (!(x = (t_rufus *)object_alloc(rufus_class))) {        object_free(x);        return NULL;    }           	dsp_setup((t_pxobject *)x, 1);	outlet_new((t_object *)x, "signal");	x->x_setcount = setcount;	x->x_actcount = 0;	x->x_waiting = false;	x->x_powerlock = false;	return (x);}