#include "ext.h"#include <stdlib.h>#define GRID_SIZE 25typedef struct t_ca1{	Object ca1_ob;	void *ca1_out;	long freq[GRID_SIZE];	long freq2[GRID_SIZE];	long amp[GRID_SIZE];	long amp2[GRID_SIZE];	float damp;	float diffuse;	long ffset;	long frate;	long limit;} t_ca1;void *ca1_class;void ca1_int(t_ca1 *x, long n);void ca1_rand(t_ca1 *x, long n,long m);void ca1_nrand(t_ca1 *x, long l, long n, long m);void ca1_nnew(t_ca1 *x, long l, long n, long m);void ca1_bang(t_ca1 *x);void ca1_damp(t_ca1 *x, float n);void ca1_diffuse(t_ca1 *x, float n);void ca1_freq(t_ca1 *x, long n);void ca1_frate(t_ca1 *x, long n);void ca1_limit(t_ca1 *x, long n);void ca1_set(t_ca1 *x, long n, long m);void *ca1_new(long n);long find_harmonic(long ideal,long aspirant,long limit);static unsigned long int next = 1;int rand(void){	next = next * 1103515245 + 12345;	return((next >> 16) & 0x7FFF);}void main(fptr *f){	setup((t_messlist **)&ca1_class, (method)ca1_new,0L, (short)sizeof(t_ca1), 0L, A_DEFLONG, 0);	addbang((method)ca1_bang);	addint((method)ca1_int);	addmess((method)ca1_set, "set", A_LONG, A_LONG, 0);	addmess((method)ca1_damp, "damp", A_FLOAT, 0);	addmess((method)ca1_diffuse, "diffuse", A_FLOAT, 0);	addmess((method)ca1_freq, "freq", A_LONG, 0);	addmess((method)ca1_rand, "rand", A_LONG, A_LONG, 0);	addmess((method)ca1_nrand, "nrand", A_LONG, A_LONG, A_LONG, 0);	addmess((method)ca1_frate, "frate", A_LONG, 0);	addmess((method)ca1_limit, "limit", A_LONG, 0);	addmess((method)ca1_limit, "nnew", A_LONG, A_LONG, A_LONG, 0);}void ca1_set(t_ca1 *x, long n, long m){	if (n >= 0 && n < GRID_SIZE) {		x->amp[n] = 100;		x->freq[n] = m;	}}void ca1_bang(t_ca1 *x){	long i,heat,nfreq,nfreq2;	float diffuse,damp;	Atom a[4];	a[0].a_type = A_LONG;	a[1].a_type = A_LONG;	a[2].a_type = A_LONG;	a[3].a_type = A_LONG;	diffuse = x->diffuse;	damp = x->damp;		for (i=0;i<GRID_SIZE;i++) 	{		x->amp2[i] = x->amp[i];		x->freq2[i] = x->freq[i];	}	for (i=1;i<GRID_SIZE-1;i++)	{		heat = (x->amp2[i-1] + x->amp2[i+1]) / damp;		if (heat > x->amp2[i])			x->amp[i] = x->amp2[i] + (heat-x->amp2[i])/diffuse;		else			x->amp[i] = x->amp2[i] - (x->amp2[i] - heat)/diffuse;		if (x->amp[i] > 127) x->amp[i] = 127;		else if (x->amp[i] < 0) x->amp[i] = 0;					nfreq = find_harmonic (x->freq2[i-1], x->freq2[i], x->limit);//		nfreq2 = find_harmonic (x->freq2[i+1], x->freq2[i], x->limit);//		if (abs(nfreq-x->freq2[i]) < abs(nfreq2-x->freq2[i]))		x->freq[i] = x->freq2[i] + ((nfreq - x->freq2[i]) / x->frate);//		else x->freq[i] = x->freq2[i] + ((nfreq2 - x->freq2[i]) / x->frate);				a[0].a_w.w_long = 1;		a[1].a_w.w_long = i/5;		a[2].a_w.w_long = i%5;		a[3].a_w.w_long = x->freq[i];		outlet_list(x->ca1_out,0,4,a);		a[0].a_w.w_long = 2;		a[1].a_w.w_long = i/5;		a[2].a_w.w_long = i%5;		a[3].a_w.w_long = x->amp[i];		outlet_list(x->ca1_out,0,4,a);			}			outlet_int(x->ca1_out,0);}long find_harmonic(long ideal,long aspirant,long limit){	long i,best,besti;		if (aspirant > ideal)	{		best = 999999;		besti = 0;		for (i=1;i<limit;i++)		{			if (abs((ideal * i) - aspirant) < best)			{				best = abs((ideal * i) - aspirant);				besti = i;			}		}			best = ideal * besti;		}	else	{		best = 999999;		besti = 0;		for (i=1;i<limit;i++)		{			if (abs((ideal / i) - aspirant) < best) 			{				best = abs((ideal / i) - aspirant);				besti = i;			}		}		best = ideal / besti;	}	return best;}void ca1_int(t_ca1 *x, long n){	long i;	for (i=0;i<GRID_SIZE;i++) 	{		x->amp[i] = rand() % n;		x->freq[i] = rand() % n*x->ffset;	}}void ca1_rand(t_ca1 *x, long n, long m){	long i;	for (i=0;i<GRID_SIZE;i++) 	{		x->amp[i] = rand() % m;		x->freq[i] = rand() % n*x->ffset;	}}void ca1_nrand(t_ca1 *x, long l, long n, long m){	long i;	for (i=0;i<l && i<GRID_SIZE;i++) 	{		x->amp[rand() % GRID_SIZE] = rand() % m;		x->freq[rand() % GRID_SIZE] = rand() % n*x->ffset;	}}void ca1_nnew(t_ca1 *x, long l, long n, long m){	long i, r;	r = rand() % GRID_SIZE;	for (i=0;i<l && i<GRID_SIZE;i++) 	{		x->amp[r] = m;		x->freq[r] = n*x->ffset;	}}void ca1_damp(t_ca1 *x, float n){	x->damp = n;}void ca1_diffuse(t_ca1 *x, float n){	x->diffuse = n;}void ca1_freq(t_ca1 *x, long n){	x->ffset = n;}void ca1_frate(t_ca1 *x, long n){	x->frate = n;}void ca1_limit(t_ca1 *x, long n){	x->limit = n;}void *ca1_new(long n){	t_ca1 *x;		x = newobject(ca1_class);	// get memory for a new object & initialize	x->ca1_out = intout(x);  // create an int outlet	x->diffuse = 3;	x->damp = 2;	x->ffset = 50;	x->limit = 7;	return (x);	}	