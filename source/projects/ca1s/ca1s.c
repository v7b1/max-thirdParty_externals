#include "ext.h"#include "ext_obex.h"#include "ext_common.h"#define GRID_SIZE 25typedef struct t_ca1{	t_object ca1_ob;	void *ca1_out;	long freq[GRID_SIZE+1];	long amp[GRID_SIZE+1];	float damp;	float diffuse;	long ffset;	float frate;	long limit;} t_ca1;static t_class *ca1_class;void ca1_int(t_ca1 *x, long n);void ca1_rand(t_ca1 *x, long n,long m);void ca1_nrand(t_ca1 *x, long l, long n, long m);void ca1_nnew(t_ca1 *x, long l, long n, long m);void ca1_bang(t_ca1 *x);void ca1_damp(t_ca1 *x, double n);void ca1_diffuse(t_ca1 *x, double n);void ca1_freq(t_ca1 *x, long n);void ca1_frate(t_ca1 *x, double n);void ca1_limit(t_ca1 *x, long n);void ca1_set(t_ca1 *x, long n, long m);void *ca1_new(long n);long find_harmonic(long ideal,long aspirant,long limit);void ca1_assist(t_ca1 *x, void *b, long m, long a, char *s);static unsigned long int next = 1;int rand(void) {	next = next * 1103515245 + 12345;	return((next >> 16) & 0x7FFF);}void ext_main(void* r){	t_class *c;	c = class_new("ca1s", (method)ca1_new, 0, (short)sizeof(t_ca1), 0L, A_DEFLONG, 0L);	class_addmethod(c, (method)ca1_assist, "assist", A_CANT,0);		class_addmethod(c, (method)ca1_bang, "bang", 0);	class_addmethod(c, (method)ca1_int, "int", A_LONG, 0);	class_addmethod(c, (method)ca1_set, "set", A_LONG, A_LONG, 0);	class_addmethod(c, (method)ca1_damp, "damp", A_FLOAT, 0);	class_addmethod(c, (method)ca1_diffuse, "diffuse", A_FLOAT, 0);	class_addmethod(c, (method)ca1_freq, "freq", A_LONG, 0);	class_addmethod(c, (method)ca1_rand, "rand", A_LONG, A_LONG, 0);	class_addmethod(c, (method)ca1_nrand, "nrand", A_LONG, A_LONG, A_LONG, 0);	class_addmethod(c, (method)ca1_frate, "frate", A_FLOAT, 0);	class_addmethod(c, (method)ca1_limit, "limit", A_LONG, 0);	class_addmethod(c, (method)ca1_limit, "nnew", A_LONG, A_LONG, A_LONG, 0);	class_register(CLASS_BOX, c);	ca1_class = c;}void ca1_set(t_ca1 *x, long n, long m){	if (n >= 0 && n < GRID_SIZE) {		x->amp[n] = 100;		x->freq[n] = m;	}}void ca1_bang(t_ca1 *x){	long i, heat, nfreq, limit;	float diffuse, damp, frate;	long amp2[GRID_SIZE+1];	long freq2[GRID_SIZE+1];	t_atom a[4];	diffuse = x->diffuse;	damp = x->damp;	limit = x->limit;	frate = x->frate;	// make a copy	for (i=0;i<=GRID_SIZE;i++) {		amp2[i] = x->amp[i];		freq2[i] = x->freq[i];	}	// first value	heat = (amp2[GRID_SIZE] + amp2[1]) / damp;	x->amp[0] = amp2[0] + (heat-amp2[0])/diffuse;		x->amp[0] = CLAMP(x->amp[0], 0, 127);	nfreq = find_harmonic (freq2[GRID_SIZE], freq2[0], limit);	x->freq[0] = freq2[0] + ((nfreq - freq2[0]) / frate);	atom_setlong(a, 1);	atom_setlong(a+1, 0);	atom_setlong(a+2, 0);	atom_setlong(a+3, x->freq[0]);	outlet_list(x->ca1_out, 0, 4, a);		atom_setlong(a, 2);	atom_setlong(a+1, 0);	atom_setlong(a+2, 0);	atom_setlong(a+3, x->amp[0]);	outlet_list(x->ca1_out, 0, 4, a);		// all in the middle	for (i=1; i<GRID_SIZE; i++)	{		heat = (amp2[i-1] + amp2[i+1]) / damp;		x->amp[i] = amp2[i] + (heat-amp2[i])/diffuse;			x->amp[i] = CLAMP(x->amp[i], 0, 127);		nfreq = find_harmonic (freq2[i-1], freq2[i], limit);		x->freq[i] = freq2[i] + ((nfreq - freq2[i]) / frate);		atom_setlong(a, 1);		atom_setlong(a+1, i/5);		atom_setlong(a+2, i%5);		atom_setlong(a+3, x->freq[i]);		outlet_list(x->ca1_out, 0, 4, a);	   		atom_setlong(a, 2);		atom_setlong(a+1, i/5);		atom_setlong(a+2, i%5);		atom_setlong(a+3, x->amp[i]);		outlet_list(x->ca1_out, 0, 4, a);			}				outlet_int(x->ca1_out, 0);}long find_harmonic(long ideal, long aspirant, long limit){	long i, best, besti;	float diff;		if (aspirant > ideal) {		best = 999999;		besti = 0;		for (i=1; i<limit; i++)		{			diff = labs((ideal * i) - aspirant);			if (diff < best) {				best = diff;				besti = i;			}		}			best = ideal * besti;		}	else {		best = 999999;		besti = 0;		for (i=1; i<limit; i++)		{			diff = labs((ideal / i) - aspirant);			if (diff < best) {				best = diff;				besti = i;			}		}		best = ideal / besti;	}	return best;}void ca1_int(t_ca1 *x, long n){	long i;	for (i=0; i<GRID_SIZE; i++) {		x->amp[i] = rand() % n;		x->freq[i] = rand() % n*x->ffset;	}}void ca1_rand(t_ca1 *x, long n, long m){	long i;	for (i=0;i<=GRID_SIZE;i++) 	{		x->amp[i] = rand() % m;		x->freq[i] = rand() % n*x->ffset;		//post("freq[%d]: %ld -- amp[%d]: %ld\n", i, x->freq[i], i, x->amp[i]);	}}void ca1_nrand(t_ca1 *x, long l, long n, long m){	long i;	for (i=0; i<l && i<=GRID_SIZE; i++) {		x->amp[rand() % (GRID_SIZE+1)] = rand() % m;		x->freq[rand() % (GRID_SIZE+1)] = rand() % n*x->ffset;	}}void ca1_nnew(t_ca1 *x, long l, long n, long m){	long i, r;	r = rand() % (GRID_SIZE+1);	for (i=0; i<l && i<=GRID_SIZE; i++) 	{		x->amp[r] = m;		x->freq[r] = n*x->ffset;	}}void ca1_damp(t_ca1 *x, double n) {	x->damp = n;}void ca1_diffuse(t_ca1 *x, double n) {	x->diffuse = n;}void ca1_freq(t_ca1 *x, long n) {	x->ffset = n;}void ca1_frate(t_ca1 *x, double n) {	x->frate = n;}void ca1_limit(t_ca1 *x, long n) {	x->limit = n;}void *ca1_new(long n){	//int i;	t_ca1 *x = object_alloc(ca1_class);		if(x) {		x->ca1_out = intout(x);  // create an int outlet				x->diffuse = 3;		x->damp = 2;		x->ffset = 50;		x->limit = 7;		x->frate = 1;			return (x);		}	else {		return x;	}}	void ca1_assist(t_ca1 *x, void *b, long m, long a, char *s) {	if (m==ASSIST_INLET) sprintf (s,"(float) input number, (list) bit pattern");	else {		switch(a) {			case 0: sprintf (s,"(list) bit pattern"); break;			case 1: sprintf(s, "(int) bit pattern as integer number"); break;			case 2: sprintf(s, "(float) corresponding float value"); break;		}	}}