/*

        Copyright (C) 1999 Juhana Sadeharju
                       kouhia at nic.funet.fi

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

    */

#ifndef GVERB_H
#define GVERB_H

#ifndef _WINDOWS
#include <math.h>
#include <string.h>
#endif
#include "gverbdsp.h"
#include "gverb~.h"
#include "ext.h"
#include "ext_common.h"
#include "z_dsp.h"

#include "ext_obex.h"



#define FDNORDER 4

typedef struct
{
	t_pxobject p_obj;
	int bypass;
	int rate;
	double inputbandwidth;
	double drylevel;
	double taillevel;
	double earlylevel;
	ty_damper *inputdamper;
	double maxroomsize;
	double roomsize;
	double revtime;
	double maxdelay;
	double largestdelay;
	ty_fixeddelay **fdndels;
	double *fdngains;
	int *fdnlens;
	ty_damper **fdndamps; 
	double fdndamping;
	ty_diffuser **ldifs;
	ty_diffuser **rdifs;
	ty_fixeddelay *tapdelay;
	int *taps;
	double *tapgains;
	double *d;
	double *u;
	double *f;
	double alpha;
} ty_gverb;


static t_class *gverb_class;



void *gverb_new(t_symbol *s, short argc, t_atom *argv);
void gverb_free(ty_gverb *);
void gverb_flush(ty_gverb *);
static void gverb_do(ty_gverb *, double, double *, double *);
static void gverb_set_roomsize(ty_gverb *, double);
static void gverb_set_revtime(ty_gverb *, double);
static void gverb_set_damping(ty_gverb *, double);
static void gverb_set_inputbandwidth(ty_gverb *, double);
static void gverb_set_drylevel(ty_gverb *, double);
static void gverb_set_earlylevel(ty_gverb *, double);
static void gverb_set_taillevel(ty_gverb *, double);
static void gverb_set_bypass(ty_gverb *p, long a);
static void gverb_print(ty_gverb *p);
void gverb_assist(ty_gverb *p, void *b, long m, long a, char *s);

static void gverb_dsp(ty_gverb *p, t_signal **sp);
void gverb_dsp64(ty_gverb *p, t_object *dsp64, short *count, double samplerate,
                 long maxvectorsize, long flags);
void gverb_perform64(ty_gverb *p, t_object *dsp64, double **ins, long numins,
                     double **outs, long numouts, long sampleframes, long flags, void *userparam);

/*
 * This FDN reverb can be made smoother by setting matrix elements at the
 * diagonal and near of it to zero or nearly zero. By setting diagonals to zero
 * means we remove the effect of the parallel comb structure from the
 * reverberation.  A comb generates uniform impulse stream to the reverberation
 * impulse response, and thus it is not good. By setting near diagonal elements
 * to zero means we remove delay sequences having consequtive delays of the
 * similar lenths, when the delays are in sorted in length with respect to
 * matrix element index. The matrix described here could be generated by
 * differencing Rocchesso's circulant matrix at max diffuse value and at low
 * diffuse value (approaching parallel combs).
 *
 * Example 1:
 * Set a(k,k), for all k, equal to 0.
 *
 * Example 2:
 * Set a(k,k), a(k,k-1) and a(k,k+1) equal to 0.
 *
 * Example 3: The transition to zero gains could be smooth as well.
 * a(k,k-1) and a(k,k+1) could be 0.3, and a(k,k-2) and a(k,k+2) could
 * be 0.5, say.
 */

static inline void gverb_fdnmatrix(double *a, double *b)
{
  const double dl0 = a[0], dl1 = a[1], dl2 = a[2], dl3 = a[3];

  b[0] = 0.5*(+dl0 + dl1 - dl2 - dl3);
  b[1] = 0.5*(+dl0 - dl1 - dl2 + dl3);
  b[2] = 0.5*(-dl0 + dl1 - dl2 + dl3);
  b[3] = 0.5*(+dl0 + dl1 + dl2 + dl3);
}

static inline void gverb_do(ty_gverb *p, double x, double *yl, double *yr)
{
	double z;
	unsigned int i;
	double lsum,rsum,sum,sign;
    
	if(IS_NAN_DOUBLE(x) || IS_DENORM_DOUBLE(x) || fabs(x) > 100000.)
	{
		x = 0.0;
	}

	z = damper_do(p->inputdamper, x);

	z = diffuser_do(p->ldifs[0],z);

    
	for(i = 0; i < FDNORDER; i++)
	{
		p->u[i] = p->tapgains[i]*fixeddelay_read(p->tapdelay,p->taps[i]);
	}
	fixeddelay_write(p->tapdelay,z);

	for(i = 0; i < FDNORDER; i++)
	{
		p->d[i] = damper_do(p->fdndamps[i],
							p->fdngains[i]*fixeddelay_read(p->fdndels[i],
							p->fdnlens[i]));
	}

	sum = 0.0;
	sign = 1.0;
	for(i = 0; i < FDNORDER; i++)
	{
		sum += sign*(p->taillevel*p->d[i] + p->earlylevel*p->u[i]);
		sign = -sign;
	}
	sum += x*p->earlylevel;
	lsum = sum;
	rsum = sum;

	gverb_fdnmatrix(p->d,p->f);

	for(i = 0; i < FDNORDER; i++)
	{
		fixeddelay_write(p->fdndels[i],p->u[i]+p->f[i]);
	}

	lsum = diffuser_do(p->ldifs[1],lsum);
	lsum = diffuser_do(p->ldifs[2],lsum);
	lsum = diffuser_do(p->ldifs[3],lsum);
	rsum = diffuser_do(p->rdifs[1],rsum);
	rsum = diffuser_do(p->rdifs[2],rsum);
	rsum = diffuser_do(p->rdifs[3],rsum);

	*yl = lsum;
	*yr = rsum;

}

static inline void gverb_set_roomsize(ty_gverb *p, double a)
{
	unsigned int i;

	if(a <= 1.0 || IS_NAN_DOUBLE(a))
	{
		p->roomsize = 1.0;
	}
	else
	{
		p->roomsize = CLAMP(a, 1.0, p->maxroomsize);
	}
	p->largestdelay = p->rate * p->roomsize * 0.00294;

	p->fdnlens[0] = ff_round(1.000000*p->largestdelay);
	p->fdnlens[1] = ff_round(0.816490*p->largestdelay);
	p->fdnlens[2] = ff_round(0.707100*p->largestdelay);
	p->fdnlens[3] = ff_round(0.632450*p->largestdelay);
	for(i = 0; i < FDNORDER; i++)
	{
		p->fdngains[i] = -pow(p->alpha, p->fdnlens[i]);
	}

	p->taps[0] = 5+ff_round(0.410*p->largestdelay);
	p->taps[1] = 5+ff_round(0.300*p->largestdelay);
	p->taps[2] = 5+ff_round(0.155*p->largestdelay);
	p->taps[3] = 5+ff_round(0.000*p->largestdelay);

	for(i = 0; i < FDNORDER; i++)
	{
		p->tapgains[i] = pow(p->alpha, p->taps[i]);
	}
}

static inline void gverb_set_revtime(ty_gverb *p, double a)
{
	double ga,gt;
	double n;
	unsigned int i;

	p->revtime = CLAMP(a, 0.1, 360.0);

	ga = 60.0;
	gt = p->revtime;
	ga = pow(10.0,-ga/20.0);
	n = p->rate*gt;
	p->alpha = pow(ga,1.0/n);

	for(i = 0; i < FDNORDER; i++)
	{
		p->fdngains[i] = -pow(p->alpha, p->fdnlens[i]);
	}
}

static inline void gverb_set_damping(ty_gverb *p, double a)
{
	unsigned int i;

	p->fdndamping = CLAMP(a, 0.0, 1.0);
	for(i = 0; i < FDNORDER; i++)
	{
		damper_set(p->fdndamps[i],p->fdndamping);
	}
}

static inline void gverb_set_inputbandwidth(ty_gverb *p, double a)
{
	p->inputbandwidth = CLAMP(a, 0.0, 1.0);
	damper_set(p->inputdamper,1.0 - p->inputbandwidth);
}

static inline void gverb_set_drylevel(ty_gverb *p, double a)
{
	a = CLAMP(a, -90.0, 0.0);
	p->drylevel = DB_CO(a);
}

static inline void gverb_set_earlylevel(ty_gverb *p, double a)
{
	a = CLAMP(a, -90.0, 0.0);
	p->earlylevel = DB_CO(a);
}

static inline void gverb_set_taillevel(ty_gverb *p, double a)
{
	a = CLAMP(a, -90.0, 0.0);
	p->taillevel = DB_CO(a);
}

#endif
