/*************************************************************//**** slice~.c - Nao Tokui, nao1091@mac.com, Jan 2005 ********//*************************************************************/// 64-bit version and additional tweaks, volker böhm - Jul 2015#include "ext.h"#include "ext_obex.h"#include "ext_common.h" // contains CLIP macro#include "z_dsp.h"#include "ext_buffer.h"//#define SAMPLE_INTERVAL 5000// better set this in milliseconds to be independant of sampling rate#define SAMPLE_INTERVAL 113.4	// vb, in milliseconds#define DEF_RMS_COEF 0.25#define DEF_THRESH  0.09#define DEF_LOW_THRESH 0.08#define LOOK_BACK 20			// vb, in milliseconds//#define LOADMESSAGE "slice~ by nao tokui :: nao1091@mac.com"//#define VERSION "slice~ version 1.0, Jan 2005"#define VERSION "slice~ by nao tokui :: nao1091@mac.com :: version 1.2 -- additional tweaks by volker böhm"//#define DEFAULT_MAX_SEGMENT_NUM 256void *slice_class;/* definition of slice~ object */typedef struct _slice{	t_pxobject l_obj;	t_buffer_ref		*bufref;			// target buffer reference	t_symbol		*bufname;		// buffer name	long l_chan;		// (target channel) - 1	void *l_outlet1;	// list outlet (start and end points of segments)	void *l_outlet2;	// the number of segments	void *l_outlet3;	// bang out		int l_malloced; 	// flag for "Is already malloced?"	long frames;		//  stored current size of buffer~	float *tab_env,*tab_hp;	double rms_coef;  // to calcurate RMS	double thresh;		// Threshold to decide "attack" or not.	double	sample_interval, look_back;   //   long **segments; // start and end point of each segment 	int segment_num; 		// number of segment (1 - MAX_SEGMENT_NUM)      /**** temporaly value ***/	long th_point; 	// Attack point (samples)    } t_slice;void slice_set(t_slice *x, t_symbol *s);void *slice_new(t_symbol *s, long chan);void slice_float(t_slice *x, double coef);void slice_bang(t_slice *x);void slice_ft1(t_slice *x, double f);void slice_int2(t_slice *x, long n);// vb, some additional functions for further tweakingvoid slice_setInterval(t_slice *x, double f);void slice_lookback(t_slice *x, double f);void slice_assist(t_slice *x, void *b, long m, long a, char *s);void slice_dblclick(t_slice *x);t_max_err slice_notify(t_slice*x, t_symbol *s, t_symbol *msg, void *sender, void *data);void slice_bang_do (t_slice *x, t_symbol *s, short argc, t_atom *argv);//void slice_bangout_do(t_slice *x, t_symbol *s, short argc, t_atom *argv);void slice_malloc(t_slice *x);void slice_free(t_slice *x);long find_zerocross(long a, long b,float *table, long tab_size);float table_complement(float *tab,float f_idx);/* main function */void ext_main(void *r){	t_class *c;		c = class_new("slice~", (method)slice_new, (method)slice_free, (short)sizeof(t_slice), 0L, A_SYM, A_DEFLONG, 0L);	//setup((t_messlist **)&slice_class, (method)slice_new, 0L, (short)sizeof(t_slice), 0L, A_SYM, A_DEFLONG, 0);		/* addmess */	class_addmethod(c, (method)slice_set, "set", A_SYM, 0);  	// "set" message changes target buffer~	class_addmethod(c, (method)slice_float, "float", A_FLOAT, 0);		// set rms feedback coef					class_addmethod(c, (method)slice_bang, "bang", 0);				// start splicing	class_addmethod(c, (method)slice_ft1,"ft1", A_FLOAT, 0);                // set threshold to determin 'attack' or not.	class_addmethod(c, (method)slice_int2, "in2", A_LONG, 0);				// set the number of desired slices	class_addmethod(c, (method)slice_setInterval, "interval", A_FLOAT, 0);	class_addmethod(c, (method)slice_lookback, "lookback", A_FLOAT, 0);	class_addmethod(c, (method)slice_assist, "assist", A_CANT, 0); 		// help	class_addmethod(c, (method)slice_dblclick, "dblclick", A_CANT, 0); 	// double click to see buffer~ contents	class_addmethod(c, (method)slice_notify, "notify", A_CANT, 0);	class_register(CLASS_BOX, c);	slice_class = c;		post(VERSION); // display message and version in the Max Window.}/* "set" message changes target buffer~ */void slice_set(t_slice *x, t_symbol *s) {		if (!x->bufref)		x->bufref = buffer_ref_new((t_object*)x, s);	else		buffer_ref_set(x->bufref, s);		x->bufname = s;	}/* malloc required memory */void slice_malloc(t_slice *x){	if (x->l_malloced==false){ // allocate memory for tables used in cutting		//x->tab_env=t_getbytes(sizeof(float)*x->frames);		//x->tab_hp=t_getbytes(sizeof(float)*x->frames);				x->tab_env = (float*)sysmem_newptr(sizeof(float)*x->frames);		x->tab_hp = (float*)sysmem_newptr(sizeof(float)*x->frames);			if (x->tab_env==NULL||x->tab_hp==NULL) {			object_error((t_object *)x, "slice~: memory allocation error");			return;		} else			x->l_malloced = true;	}}/* changing feedback coefficient by float number in right inlet */// vb, that should probably read "left inlet"void slice_float(t_slice *x, double coef)  {	x->rms_coef = coef;	//post("rms feedback coef: %f",x->rms_coef);}/* bang start splicing (left most inlet) */void slice_bang(t_slice *x)  {	x->segment_num=0;	defer(x, (method)slice_bang_do, 0L, 0, 0L);}/*********************************************************************//***************   SLICING FUNCTION                *******************//*********************************************************************/void slice_bang_do (t_slice *x, t_symbol *s, short argc, t_atom *argv){		t_buffer_obj	*b;		// target buffer  	float *tab;	long idx0,idx1,chan, nc, frames;	double xx;				double fb,fb2;					float coef, maxv, sr;		t_atom outList[3];	long lb_samp, samp_interv;	long start_p, end_p;			/* get target buffer~ */	b = buffer_ref_getobject(x->bufref);		/* exception handling */	if (!b) {		object_error((t_object *)x, "slice~: invalid buffer~ %s", x->bufname->s_name);		return;	}		tab = buffer_locksamples(b);				// vb, lock buffer and access samples	if (!tab) return;	frames = buffer_getframecount(b);	x->frames = frames;	chan = x->l_chan; 		// channel to scan	nc = buffer_getchannelcount(b); 		// number of channels in buffer~	chan = CLAMP(chan, 1, nc);	chan -= 1;	sr = buffer_getsamplerate(b);	fb = 0.0;				// value of sample to feedback	fb2 = 0.0;	x->segment_num = 0;	// number of segments		/* memory allocation */	slice_malloc(x);	if (x->l_malloced==false) {		buffer_unlocksamples(b);		return;	}	coef = x->rms_coef;			// feedback coefficient	idx0 = 0;					// frame index to scan//	x->th_point=0-SAMPLE_INTERVAL;	x->th_point=1;	maxv = 0.0;		/* making envelope table */	while (idx0 < frames){		idx1 = idx0*nc + chan;			// index converted		xx = tab[idx1];		xx = xx * xx;					// square 				xx = (xx * (1 - coef)) + (fb * coef);	// filter		fb = xx;						// store feedback value		xx = sqrt(xx);					// square root		x->tab_env[idx0] = xx;		idx0++; 	}		buffer_unlocksamples(b);		// vb, unlock the buffer		/* find maximum amplitude in the buffer */	for (idx0=0;idx0<frames;idx0++){		if (maxv<x->tab_env[idx0]) maxv = x->tab_env[idx0];	}		/* normalization of amplitude */	if (maxv!=0.0){		for (idx0=0;idx0<frames;idx0++){			x->tab_env[idx0]=x->tab_env[idx0]/maxv;		}	}		/* making buffer table after rms+high pass filter */ 	for (idx0=0;idx0<frames;idx0++){		xx = x->tab_env[idx0];		/* vb, hm, this looks like an unstable filter 		xx = (1.3*xx - 0.9*fb2)*(1.3*xx - 0.9*fb2);		x->tab_hp[idx0]=xx;		fb2 = xx;*/		// vb, maybe this was meant:		xx = (1.3*xx - 0.9*fb2);		x->tab_hp[idx0] = xx*xx;		fb2 = xx;	}	/* splicing and output in list of start and end point of each segment */ 	idx0 = 0;	lb_samp = x->look_back * sr/1000; 	samp_interv = x->sample_interval * sr/1000;		while (idx0 < frames){		/*if (x->segment_num==0 && x->tab_hp[idx0] > DEF_LOW_THRESH) 			x->th_point=find_zerocross(idx0-LOOK_BACK,idx0,x->tab_hp);*/				if (idx0 <samp_interv && x->tab_hp[idx0] > DEF_LOW_THRESH 			&& idx0-x->th_point > samp_interv) {				x->th_point = find_zerocross(idx0-lb_samp,idx0,x->tab_hp, frames);		}		else if ((x->tab_hp[idx0-1]<DEF_LOW_THRESH&&x->tab_hp[idx0]>x->thresh&&idx0-x->th_point>samp_interv)			|| idx0==frames-1) {						if (x->th_point>0){								start_p = x->th_point; // start point in samples				end_p = find_zerocross(idx0-lb_samp,idx0,x->tab_hp,frames); // end point in samples								/****** checking the number of segments and storing the segment data 				if ((++(x->segment_num))< x->current_max_segment) {					x->segments[x->segment_num][0] = start_p; 					x->segments[x->segment_num][1] = end_p; 				} else {					error("too many segments...");					break;				}******/								(x->segment_num)++;								atom_setlong(&outList[0],x->segment_num);				atom_setfloat(&outList[1],((float)start_p/sr)*1000.0);	// start point in ms 	// vb, eliminated "+1"				atom_setfloat(&outList[2], ((float)end_p/sr)*1000.0); 	// end point in ms				outlet_list(x->l_outlet1,0L,3,outList); 			// list output 				 				x->th_point  = end_p;			} 		}		idx0++;	}		/* free allocated memory */ 	if (x->l_malloced){		// free memory for buffer		sysmem_freeptr(x->tab_hp);		sysmem_freeptr(x->tab_env);		x->l_malloced=false;	}		/* output bang when splicing is finished */	outlet_int(x->l_outlet2, x->segment_num);	outlet_bang(x->l_outlet3);}/* find (quasi) zero crossing point (i.e., minimum value) */long find_zerocross(long a, long b, float *table, long tab_size){	long min;	float minv;	long i;		min = a;	minv=1.0;	for (i=a;i<b;i++){		if (i>=0 && i<tab_size){			if (table[i]<minv) {				minv=table[i];				min = i;			}		}	}	return min;}/* set threshold to decide "attack" or not*/void slice_ft1(t_slice *x, double f) {	if (f!=0.0) x->thresh = f / 10.0;	//post("threshold: %f",x->thresh);}void slice_int2(t_slice *x, long n){	// vb, does nothing	//post("int2: %d", n);}void slice_setInterval(t_slice *x, double f) {	x->sample_interval = CLAMP(f, 1, f);}void slice_lookback(t_slice *x, double f) {	x->look_back = CLAMP(f, 1, f);}/* double click to show sound wave */void slice_dblclick(t_slice *x) {	buffer_view(buffer_ref_getobject(x->bufref));}t_max_err slice_notify(t_slice*x, t_symbol *s, t_symbol *msg, void *sender, void *data) {	return buffer_ref_notify(x->bufref, s, msg, sender, data);}void slice_assist(t_slice *x, void *b, long m, long a, char *s) {	if (m==ASSIST_INLET) {		switch(a) {			case 0: sprintf (s,"(bang) start segmentation"); break;			case 1: sprintf (s,"(float) threshold"); break;			case 2: sprintf (s,"(int) inactive"); break;		}	}	else {		switch(a) {			case 0: sprintf (s,"(list) index, start point, end point"); break;			case 1: sprintf(s, "(int) number of slices"); break;			case 2: sprintf(s, "(bang) bang when finished"); break;		}			}}void slice_free(t_slice *x) {	if(x->bufref) object_free(x->bufref);}/* generate new instance */void *slice_new(t_symbol *s, long chan) {	t_slice *x = object_alloc(slice_class);		if(x) {		// add inlets (3 in total)		intin((t_object *)x, 2);		// vb, inactive		floatin((t_object *)x,1);																// generate outlet (right to left)		x->l_outlet3 = bangout((t_object *)x);		x->l_outlet2 = intout((t_object *)x);		x->l_outlet1 = listout((t_object *)x);							x->bufref = NULL;		slice_set(x, s);		x->l_chan = chan;				x->rms_coef = DEF_RMS_COEF;	// default feedback coef.		x->thresh = DEF_THRESH;		x->sample_interval = SAMPLE_INTERVAL;		x->look_back = LOOK_BACK;		x->segment_num = 0;		x->l_malloced = false;	   // x->current_max_segment = DEFAULT_MAX_SEGMENT_NUM;				}	else {		object_free(x);		x = NULL;	}	return (x);	}